第1章：

第2章：
DISTINCTはSELECTしたカラムが完全一致の場合に重複扱いして除く。
WHEREは先にWHEREで条件が合うものを探して、SELECTで出力してる
WHERE句に指定したカラムは必ずしもSELECTで出力しなくていい
SELECT -> FROM -> WHEREの順(WHEREはFROMのすぐ後ろ)
NULLが含む計算は問答無用でNULL（5 + NULLみたいな値が欲しいときもあるけど、それは後述）
否定の演算子は<>(!=でもいけるけど標準的なのは<>)
str数字は辞書順に大小
NULLはIS NULLで検証する（IS NOT NULL NULLでないもの）
AND演算子のほうが優先されるためORを優先するときは（）をつける
ANDはUNKNOWとFALSEのときはFALSEが、ORはUNKNOWNとFALSEの時はUNKNOWN（ここは今後要注意）


第3章：

COUNTの引数に指定したカラムはNULLを除外した数を出力、＊するとNULLを含む行数を出力
AVGもNULLを除外して計算するけど、分母もNULLがなくなった分になる（０としてカウントする場合は後述）
現時点ではSELECT -> FROM -> WHERE -> GROUP BYの順（でも、動く順番はFROM -> WHERE -> GROUP BY -> SELECT）
WHEREはレコードの絞り込みにしか使えない、GROUP BYした後の条件を付ける場合はHAVINGを使う
HAVINGを使うときはGROUP BYでできた新しいテーブルに対してさらに条件を付けるってイメージするとよき
その句が先に動いて後に動くかを考える

第4章：
INSERT SELECTでテーブルのコピーができ、GROUP BYも使える
DELETE FROM TableName
DELETEはWHEREしか使えない（まあ当たり前ではある）
全レコード削除の際はTRUNCATEもある（DELETEより軽いけど使用注意）
DBに接続し最初のSQLを発行した時点でTRANSACTIONが開始されている

ACID特性
    原子性：TRANSACTION内のDMLはすべてCOMMITかすべてROLLBACKのみ
    一貫性：テーブルのルールに従っている
    独立性：COMMIT前のDMLは外からの影響を受けない、与えない
    永続性：TRANSACTIONが終了した時点でデータの状態が保存されていること
VALUEは手入力の値
    INSERT INTO TableName (name, price) VALUES ('リンゴ', 100)
SELECTはレコードを持ってくる


第5章：
テーブルは実データ、ViewはSELECT文自体
Viewは多段にできる、けどしすぎない
Viewの定義にはORDER BYは使わないように
Viewに対して更新は原則できない
    (shohin_bunrui, COUNT(*))
    INSERT INTO ShohinSum VALUES ('電化製品', 5) としても、Viewはもとにデータと連動しており、これだと、shohin_bunruiと行数しかわからず
    レコードに追加できないから。逆に言えば、このように集約したものでなく、すべてのデータを書けるようなViewは更新が可能。
    （要はViewだけをみて元のテーブルを更新できないか否か）

サブクエリは使い捨てのView
サブクエリの使いどころはサブクエリにてSQLを発行して結果を得て、その結果をもとにさらに大本でSQLを発行し結果を得る
スカラ・サブクエリは単一の結果を返すサブクエリ。演算子で比較できるようにするため
相関サブクエリは「商品分類ごとに平均販売価格が高い商品」さらに小分けにしてそれぞれで出力できるように
相関サブクエリで使う別名はスコープあり（まあ当たり前ではある）
相関サブクエリは使ってみるとちょっと複雑かも、要練習


第6章：
ROUND(対象数, 四捨五入して最終的に小数点何位まで求めるかの値)
LNGTHで文字列を数えられるが、文字数を数える場合もあれば、バイト数を数える場合もある
REPLACE(対象文字列, 置換前の文字列, 置換後の文字列)
SUBSTRING(対象文字列 FROM 切り出し開始文字数目 FOR 切り出し文字数)
日時関数はDBMSによって差がある
CURRENT_TIMESTAMPはCURRENT_DATE + CURRENT_TIME
COALESCEは引数を左から検証して最初にNULLじゃない値を出力。すべてNULLならNULL
    例えば、集計や計算でNULLを0として計算したいときに
    SELECT COALESCE(price, 0) AS price FROM Product

述語は戻り値が真になるものを出力するもの
LIKE は一致があるかどうか '%abc' = 前方一致があるか　'_abc' = 前方一致があるか（Underscoreの数は文字数）
BETWEEN は範囲検索 Between 100 AND 1000 は両端を含む。含ませたくない場合は WHERE something > 100 AND something < 1000 ; 
IN (100, 200, 300) は WHERE something = 100 OR something = 200 OR something = 300 ; OR句を簡単に書ける
NOT INで除外も可 

第7章：
行方向に作用するものと列方向に作用するものがある
UNIONはレコードを足す。通常、重複レコードは排除される
注意点：
    カラム数は同じである
    データ型が同じである
    ORDER BYは最後につける（結局途中でつけても最終出力に対してORDER BYするから途中にあっても意味ない）

UNION ALLで重複を含む
INTERSECTは両テーブルの共通部分を表示する（ベン図でいう重なっているところ）
INTERSECT ALLで重複を表示

EXCEPTはテーブルの引き算のイメージ
引き算なのでどちらを引くテーブルにするかで結果が変わる

列方向の結合（JOIN）
例：（INNER JOIN）
SELECT TS.tenpo_id, TS.tenpo_mei, TS.shohin_id, S.shohin_mei, S.hanbai_tanka
  FROM TenpoShohin AS TS INNER JOIN Shohin AS S
    ON TS.shohin_id = S.shohin_id
ORDER BY tenpo_id;

例：（OUTER JOIN）
SELECT TS.tenpo_id, TS.tenpo_mei, S.shohin_id, S.shohin_mei, S.hanbai_tanka
  FROM TenpoShohin TS RIGHT OUTER JOIN Shohin S
    ON TS.shohin_id = S.shohin_id
ORDER BY tenpo_id;

内部結合：ON TS.shohin_id = S.shohin_idをしたときに、ないものは表示されない（この場合はどこの店舗でも扱ってないもの）
外部結合：ON TS.shohin_id = S.shohin_idしてもお互いにすべてのレコードを合体させて、ない分はNULL（本当に外部からのデータをくっつけるイメージ）
        RIGHT, LEFTはそれぞれ右、左にあるテーブルをマスタにする。

CROSS JOINは両テーブルを掛け合わせたもの

第8章：
ウィンドウ関数
SELECT　列名, RANK () OVER (PARTITION BY 列名 ORDER BY ソートする列名)
PARTITION BY 列名　は列名ごとにカットするイメージ。カットしてそれぞれの列名で ORDER BYに沿って順位付けする

RANK: 1,1,1,4
DENSE_RANK: 1,1,1,2
ROW_NUMBER: 1,2,3,4

ウィンドウ関数はSELECTでしか使えない（これも表示用にソートするものだから、途中でソートする必要ないから、WHEREとかにかけない）
集約関数はウィンドウ関数として書くことが可能
ROWS 数字 PRECEDING: ウィンドウごとに切られたレコードの集まりのなかでさらに細かく分ける
    ROWS 2 PRECEDINGだったら、カレントレコード、その1行前、2行前が選択されている
    ROWS 2 FOLLWOINGだったら、カレントレコード、その1行後、2行後が選択されている

前後の比較をするときに便利だね

ROLLUPはGROUP BYに引数につける。
    GROUP BY ROLLUP(shohin_bunrui)は内部的には
    1. GROUP BY ()
    2. GROUP BY (shohin_bunrui)
    で処理される。＝合計（１）と商品分類ごとの小計（２）が求められる
    （すこしむずい）

GROUPING: 引数に取った列の値が超集合行のために生じたNULLなら１を返し、それ以外は０を返す
１の時には'合計'みたいな文言を入れられるけど、そのときにはデータの型に注意

CUBEはROLLUPに加えて、引数のすべての組み合わせで出力する
    ROUP BY ROLLUP(shohin_bunrui, torokubi)は内部的には
    1. GROUP BY ()
    2. GROUP BY (shohin_bunrui)
    3. GROUP BY (torokubi)
    4. GROUP BY (shohin_bunrui, torokubi)
    で処理される。

GROUPING SETS: 引数に取った集約キーのみで集約したいとき（？）
